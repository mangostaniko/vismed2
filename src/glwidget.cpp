#include "glwidget.h"

#include "mainwindow.h"

GLWidget::GLWidget(QWidget *parent)
    : QOpenGLWidget(parent)
    , volume(nullptr)
{
	mainWindow = qobject_cast<MainWindow *>(this->parent()->parent()->parent());

	// set minimum required opengl version
	QSurfaceFormat format = QSurfaceFormat();
	format.setVersion(4, 5);
	format.setProfile(QSurfaceFormat::CoreProfile);
	this->setFormat(format);
	qDebug() << this->format() << "\n";
}

GLWidget::~GLWidget()
{
	delete logger;

	delete raycastShader;
	delete rayVolumeExitPosMapShader;

	delete transferFunction1DTex;
	delete rayVolumeExitPosMapFramebuffer;
	delete volume3DTex;
	delete gradients3DTex;
}

void GLWidget::initializeGL()
{

	QWidget::setFocusPolicy(Qt::FocusPolicy::ClickFocus);

	initializeOpenGLFunctions();

	// print glError messages
	logger = new QOpenGLDebugLogger(this);
	logger->initialize();
	connect(logger, &QOpenGLDebugLogger::messageLogged, this, &GLWidget::printDebugMsg);
	logger->startLogging();

	// get graphics device and opengl info
	QString extensions = QString((const char*)glGetString(GL_EXTENSIONS));
	QString glversion = QString((const char*)glGetString(GL_VERSION));
	QString vendor = QString((const char*)glGetString(GL_VENDOR));
	QString renderer = QString((const char*)glGetString(GL_RENDERER));

	QString deviceInfoString = "Graphics Device:\n" + renderer + "\nby " + vendor + "\nHighest supported OpenGL version: " + glversion;
	qDebug().noquote() << deviceInfoString;

	// load, compile and link vertex and fragment shaders
	initShaders();

	// initialize vertex buffer object for raw data of the cube defining the volume bounding box
	// the cube vertex positions are interpolated as colors in fragment shader
	// to yield all possible ray volume exit positions to be stored in a texture for ray traversal.
	initVolumeBBoxCubeVBO();

	// load 1D transfer function texture from image
	loadTransferFunction1DTex("../transferfunctions/tff_vascular.png");

	// init framebuffer to hold a 2D texture for volume exit positions of orthogonal rays
	// texture is autogenerated on framebuffer creation and will be filled with data later.
	initRayVolumeExitPosMapFramebuffer();

	initCamera();

	mainWindow->openFile("../data/MAGIX_512x512x369_12bit.dat");

}

void GLWidget::initCamera()
{
	camera.setProjectionType(Qt3DRender::QCameraLens::PerspectiveProjection);
	camera.setPosition(QVector3D(0,-2,0));
	camera.rotate(QQuaternion::fromEulerAngles(90,180,0));
	camera.setViewCenter(QVector3D(0,0,0));

}

void GLWidget::initShaders()
{
	raycastShader = new QOpenGLShaderProgram(QOpenGLContext::currentContext());
	raycastShader->addShaderFromSourceFile(QOpenGLShader::Vertex, "../src/shaders/raycast_shader.vert");
	raycastShader->addShaderFromSourceFile(QOpenGLShader::Fragment, "../src/shaders/raycast_shader.frag");
	raycastShader->link();

	rayVolumeExitPosMapShader = new QOpenGLShaderProgram(QOpenGLContext::currentContext());
	rayVolumeExitPosMapShader->addShaderFromSourceFile(QOpenGLShader::Vertex, "../src/shaders/rayvolumeexitposmap_shader.vert");
	rayVolumeExitPosMapShader->addShaderFromSourceFile(QOpenGLShader::Fragment, "../src/shaders/rayvolumeexitposmap_shader.frag");
	rayVolumeExitPosMapShader->link();

}

void GLWidget::initVolumeBBoxCubeVBO()
{
	// generate vertex array object (vao).
	// subsequent bindings related to vertex buffer data and shader variables
	// are stored by the bound vao, so they can conveniently be reused later.
	volumeBBoxCubeVAO.create();
	volumeBBoxCubeVAO.bind();

	// generate vertex buffer object (vbo) for raw vertex data
	QOpenGLBuffer volumeBBoxCubeVBO(QOpenGLBuffer::VertexBuffer);
	volumeBBoxCubeVBO.create();
	volumeBBoxCubeVBO.bind();
	volumeBBoxCubeVBO.setUsagePattern(QOpenGLBuffer::StaticDraw);
	volumeBBoxCubeVBO.allocate(&cubeVertices[0], 24 * sizeof(GLfloat));

	// generate index buffer object (ibo) listing vertex indices used for drawing
	QOpenGLBuffer volumeBBoxCubeIBO(QOpenGLBuffer::IndexBuffer);
	volumeBBoxCubeIBO.create();
	volumeBBoxCubeIBO.bind();
	volumeBBoxCubeIBO.setUsagePattern(QOpenGLBuffer::StaticDraw);
	volumeBBoxCubeIBO.allocate(&cubeTriangleIndices[0], 36 * sizeof(GLint));

	// bind vertex and index data to shader attributes
	rayVolumeExitPosMapShader->bind();
	int vertexPositionAttribIndex = rayVolumeExitPosMapShader->attributeLocation("vertexPosition");
	rayVolumeExitPosMapShader->enableAttributeArray(vertexPositionAttribIndex); // enable bound vertex buffer at this index
	rayVolumeExitPosMapShader->setAttributeBuffer(vertexPositionAttribIndex, GL_FLOAT, 0, 3); // 3 components x,y,z

	// unbind buffers and shader
	volumeBBoxCubeVAO.release();
	volumeBBoxCubeIBO.release();
	volumeBBoxCubeVBO.release();
	rayVolumeExitPosMapShader->release();

}

void GLWidget::loadTransferFunction1DTex(const QString &fileName)
{
	// load transfer function 1D texture from image file
	transferFunction1DTex = new QOpenGLTexture(QOpenGLTexture::Target1D);
	transferFunction1DTex->create();
	transferFunction1DTex->setFormat(QOpenGLTexture::RGB8_UNorm);
	transferFunction1DTex->setData(QImage(fileName).convertToFormat(QImage::Format_RGB888));
	transferFunction1DTex->setWrapMode(QOpenGLTexture::Repeat);
	transferFunction1DTex->setMinificationFilter(QOpenGLTexture::Nearest);
	transferFunction1DTex->setMagnificationFilter(QOpenGLTexture::Nearest);
}

void GLWidget::initRayVolumeExitPosMapFramebuffer()
{
	// init framebuffer to hold a 2D texture for volume exit positions of orthogonal rays
	// texture is autogenerated on framebuffer creation and will be filled with data later.

	QOpenGLFramebufferObjectFormat fboFormat;
	fboFormat.setAttachment(QOpenGLFramebufferObject::Depth);
	fboFormat.setTextureTarget(GL_TEXTURE_2D);
	fboFormat.setInternalTextureFormat(GL_RGBA8);

	rayVolumeExitPosMapFramebuffer = new QOpenGLFramebufferObject(this->width(), this->height(), fboFormat);

}

void GLWidget::loadVolume3DTex()
{
	if (!volume) { return; }

	// fill volumeData into a 3D texture
	if (volume3DTex) {
		volume3DTex->destroy(); delete volume3DTex; volume3DTex = nullptr;
	}
	volume3DTex = new QOpenGLTexture(QOpenGLTexture::Target3D);
	volume3DTex->create();
	volume3DTex->setFormat(QOpenGLTexture::R32F);
	volume3DTex->setWrapMode(QOpenGLTexture::Repeat);
	volume3DTex->setMinificationFilter(QOpenGLTexture::Linear); // this is trilinear interpolation
	volume3DTex->setMagnificationFilter(QOpenGLTexture::Linear);
	volume3DTex->bind();

	// we can simply pass a pointer to the voxel vector since voxels only have a float member each it is same as a float array
	// note that for some reason we need to use internalformat GL_RGB (i.e. 3 channels) since GL_INTENSITY doesnt work.
	// yet the pixel data is still interpreted as a single intensity value due to GL_INTENSITY.
	glTexImage3D(GL_TEXTURE_3D, 0,  GL_R32F, volume->getWidth(), volume->getHeight(), volume->getDepth(), 0,  GL_RED, GL_FLOAT, volume->getVoxels());

}

void GLWidget::precomputeGradients3DTex()
{
	if (!volume) { return; }

	gradients.clear();

	// gradients at each voxel are calculated using the sobel filter.
	// sobel filter kernels consist of an averaging and a difference kernel, i.e. compute the gradient with smoothing.
	// for each direction d, the smoothingKernel is applied to d+1 and d-1 to average the values along the other directions,
	// then difference of the two values is taken. here we do this for all 3 directions to build the gradient vector.

	float smoothingKernel[9] = {  1, 2, 1, 2, 4, 2, 1, 2, 1 };
	float offsets1[9]        = { -1,-1,-1, 0, 0, 0, 1, 1, 1 };
	float offsets2[9]        = { -1, 0, 1,-1, 0, 1,-1, 0, 1 };

	for (int x = 0; x < volume->getWidth(); ++x) {
		for (int y = 0; y < volume->getHeight(); ++y) {
			for (int z = 0; z < volume->getDepth(); ++z) {

				float gradientX, gradientY, gradientZ;

				for (int i = 0; i < 9; ++i) {
					gradientX += volume->valueAt(x-1, y+offsets1[i], z+offsets2[i]) * smoothingKernel[i];
					gradientX -= volume->valueAt(x+1, y+offsets1[i], z+offsets2[i]) * smoothingKernel[i];

					gradientY += volume->valueAt(x+offsets1[i], y-1, z+offsets2[i]) * smoothingKernel[i];
					gradientY -= volume->valueAt(x+offsets1[i], y+1, z+offsets2[i]) * smoothingKernel[i];

					gradientZ += volume->valueAt(x+offsets1[i], y+offsets2[i], z-1) * smoothingKernel[i];
					gradientZ -= volume->valueAt(x+offsets1[i], y+offsets2[i], z+1) * smoothingKernel[i];
				}

				gradients.push_back(QVector3D(gradientX, gradientY, gradientZ));

			}
		}
	}

	// fill gradients into a 3D texture
	if (gradients3DTex) {
		gradients3DTex->destroy(); delete gradients3DTex; gradients3DTex = nullptr;
	}
	gradients3DTex = new QOpenGLTexture(QOpenGLTexture::Target3D);
	gradients3DTex->create();
	gradients3DTex->setWrapMode(QOpenGLTexture::Repeat);
	gradients3DTex->setMinificationFilter(QOpenGLTexture::Linear); // trilinear interpolation
	gradients3DTex->setMagnificationFilter(QOpenGLTexture::Linear);
	gradients3DTex->bind();

	// TODO TEXTURE FORMAT IS BROKEN
	glTexImage3D(GL_TEXTURE_3D, 0, GL_RGB32F, volume->getWidth(), volume->getHeight(), volume->getDepth(), 0, GL_RGB, GL_FLOAT, &gradients[0]);

}

void GLWidget::dataLoaded(Volume *volumeData)
{
	volume = volumeData;

	loadVolume3DTex();
    repaint();
	//precomputeGradients3DTex();

}

void GLWidget::paintGL()
{
	glClearColor(backgroundColor.red()/256.0f, backgroundColor.green()/256.0f, backgroundColor.blue()/256.0f, 1.0f);
	glClear(GL_COLOR_BUFFER_BIT);

	if (!volume) { return; }

	glEnable(GL_DEPTH_TEST);

	///////////////////////////////////////////////////////////////////////////////
	// FIRST PASS
	// generate ray volume exit position map later used to construct rays
	///////////////////////////////////////////////////////////////////////////////

	rayVolumeExitPosMapFramebuffer->bind();

	rayVolumeExitPosMapShader->bind();

	// draw volume cube back faces (front face culling enabled)
	// rayVolumeExitPosMapShader stores interpolated back face (ray exit) positions in framebuffer texture
	drawVolumeBBoxCube(GL_FRONT, rayVolumeExitPosMapShader);

	///////////////////////////////////////////////////////////////////////////////
	// SECOND PASS
	// calculate ray volume entry positions and together with exit position map
	// do raycasting from entry to exit position of each fragment
	///////////////////////////////////////////////////////////////////////////////

	QOpenGLFramebufferObject::bindDefault();

	raycastShader->bind();
	raycastShader->setUniformValue("screenDimensions", QVector2D(this->width(), this->height()));
	raycastShader->setUniformValue("numSamples", numSamples);
	raycastShader->setUniformValue("sampleRangeStart", sampleRangeStart);
	raycastShader->setUniformValue("sampleRangeEnd", sampleRangeEnd);
	raycastShader->setUniformValue("compositingMethod", compositingMethod);
	raycastShader->setUniformValue("enableShading", enableShading);
    raycastShader->setUniformValue("shadingThreshold", shadingThreshold);
	raycastShader->setUniformValue("opacityFactor", opacityFactor);
	raycastShader->setUniformValue("opacityOffset", opacityOffset);
	raycastShader->setUniformValue("ttfSampleFactor", ttfSampleFactor);
	raycastShader->setUniformValue("ttfSampleOffset", ttfSampleOffset);
	raycastShader->setUniformValue("midaParam", midaParam);

	raycastShader->setUniformValue("transferFunction", 0); // bind shader uniform to texture unit 0
    transferFunction1DTex->bind(0); // bind texture to texture unit 0
	raycastShader->setUniformValue("exitPositions", 1);
	glActiveTexture(GL_TEXTURE0 + 1);
	glBindTexture(GL_TEXTURE_2D, rayVolumeExitPosMapFramebuffer->texture());
	raycastShader->setUniformValue("volume", 2);
	volume3DTex->bind(2);
	//raycastShader->setUniformValue("gradients", 3);
	//gradients3DTex->bind(3);

	// draw volume cube front faces (back face culling enabled)
	// raycastShader then uses interpolated front face (ray entry) positions with exit positions from first pass
	// to cast rays through the volume texture.
	// raycasting determines pixel intensity by sampling the volume voxel intensities
	// and mapping desired values to colors via the transfer function
	drawVolumeBBoxCube(GL_BACK, raycastShader);

	/*/ DEBUG VIEW FIRST PASS TEXTURE
	// blit framebuffer from first pass to default framebuffer
	// blit = bit block image transfer, combine bitmaps via boolean operation
	if (!QOpenGLFramebufferObject::hasOpenGLFramebufferBlit()) qWarning() << "Frame Buffer blitting not supported by local OpenGL implementation.";
	QOpenGLFramebufferObject::blitFramebuffer(0, rayVolumeExitPosMapFramebuffer); //*/

}

void GLWidget::drawVolumeBBoxCube(GLenum glFaceCullMode, QOpenGLShaderProgram *shader)
{
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// note that it doesnt matter to volume sampling how we transform the cube, since sampling rays are created between interpolated model space vertex positions
	modelMat.setToIdentity();
	modelMat.translate(QVector3D(-0.5, -0.5, -0.5)); // move volume bounding box cube to center

	shader->bind();
	int mvpMatUniformIndex = shader->uniformLocation("modelViewProjMat");
	shader->setUniformValue(mvpMatUniformIndex, camera.projectionMatrix() * camera.viewMatrix() * modelMat);

	glEnable(GL_CULL_FACE);
	glCullFace(glFaceCullMode);
	volumeBBoxCubeVAO.bind();
	glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, (GLuint *)NULL);
	glDisable(GL_CULL_FACE);

}

void GLWidget::setPerspective(bool enabled)
{
	if (enabled)
		camera.setProjectionType(Qt3DRender::QCameraLens::PerspectiveProjection);
	else
		camera.setProjectionType(Qt3DRender::QCameraLens::OrthographicProjection);

	repaint();
}

void GLWidget::setNumSamples(int numSamples)
{
	this->numSamples = numSamples;
	repaint();
}

void GLWidget::setSampleRangeStart(double sampleRangeStart)
{
	this->sampleRangeStart = float(sampleRangeStart);
	repaint();
}

void GLWidget::setSampleRangeEnd(double sampleRangeEnd)
{
	this->sampleRangeEnd = float(sampleRangeEnd);
	repaint();
}

void GLWidget::setShadingThreshold(double thresh)
{
    this->shadingThreshold = thresh;
    repaint();
}

void GLWidget::setOpacityFactor(float factor)
{
	this->opacityFactor = factor;
	repaint();
}

void GLWidget::setOpacityOffset(float offset)
{
	this->opacityOffset = offset;
	repaint();
}

// multiply transfer function texture lookup position with a factor
void GLWidget::setTTFSampleFactor(float factor)
{
	this->ttfSampleFactor = factor;
	repaint();
}

// offset transfer function texture lookup position
void GLWidget::setTTFSampleOffset(float offset)
{
	this->ttfSampleOffset = offset;
	repaint();
}

// value in range [-1,1]
void GLWidget::setMIDAParam(float value)
{
	this->midaParam = value;
	repaint();
}

void GLWidget::setCompositingMethod(CompositingMethod m)
{
	this->compositingMethod = m;
    repaint();
}

void GLWidget::loadTransferFunctionImage()
{
	QString fileName = QFileDialog::getOpenFileName(this, tr("Open Image"), 0, tr("Image Files (*.png *.jpg)"));
	loadTransferFunction1DTex(fileName);

	repaint();
}

void GLWidget::setShading(bool shade)
{
	this->enableShading = shade;
    repaint();
}

void GLWidget::resizeGL(int w, int h)
{
	rayVolumeExitPosMapFramebuffer = new QOpenGLFramebufferObject(w, h, QOpenGLFramebufferObject::Depth);

	//camera.setAspectRatio(float(w) / h);
}

void GLWidget::mousePressEvent(QMouseEvent *event)
{
	setNumSamples(this->NUM_SAMPLES_INTERACTIVE);
	lastMousePos = event->pos();
}

void GLWidget::wheelEvent(QWheelEvent *event)
{
	float fov = std::max(20.0f, std::min(camera.fieldOfView() - event->delta()/30, 120.0f));
	camera.setFieldOfView(fov);

	update();
}

void GLWidget::mouseMoveEvent(QMouseEvent *event)
{
	setNumSamples(this->NUM_SAMPLES_INTERACTIVE);

	int dx = event->x() - lastMousePos.x();
	int dy = event->y() - lastMousePos.y();

	if (event->buttons() & Qt::LeftButton) {

		if (event->modifiers() & Qt::ShiftModifier) {
			// move camera
			camera.translate(QVector3D(-dx/1000.f, dy/1000.f, 0));
		}
		else if (event->modifiers() & Qt::AltModifier) {
			// zoom camera
			float fov = std::max(20.0f, std::min(camera.fieldOfView() - dy/10.f, 120.0f));
			camera.setFieldOfView(fov);
		}
		else {
			// rotate camera
			camera.tiltAboutViewCenter(dy/10.f);
			camera.panAboutViewCenter(dx/10.f, QVector3D(0,0,1)); // constraint around up axis
		}
	}

	lastMousePos = event->pos();
	update();
}

void GLWidget::mouseReleaseEvent(QMouseEvent *)
{
	setNumSamples(this->NUM_SAMPLES_STATIC);
	repaint();
}

void GLWidget::keyPressEvent(QKeyEvent *event)
{
	switch (event->key()) {
		case Qt::Key_Space:
			break;
		default:
			event->ignore();
			break;
	}
}

void GLWidget::keyReleaseEvent(QKeyEvent *event)
{

}



#include "glwidget.h"

#include "mainwindow.h"

void GLWidget::initializeGL()
{
	// obtain a gl functions object and resolve all entry points
	// in this case we use QOpenGLFunctions_3_3_Core* gl functions
	// this supports glTexImage3D
	glf = QOpenGLContext::currentContext()->versionFunctions<QOpenGLFunctions_3_3_Core>();
	if (!glf) { qWarning("Could not obtain OpenGL versions object"); exit(1); }
	glf->initializeOpenGLFunctions();

	// print glError messages
	logger = new QOpenGLDebugLogger(this);
	logger->initialize();
	connect(logger, &QOpenGLDebugLogger::messageLogged, this, &GLWidget::printDebugMsg);
	logger->startLogging();

	// load, compile and link vertex and fragment shaders
	initShaders();

	// initialize vertex buffer object for raw data of the cube defining the volume bounding box
	// the cube vertex positions are interpolated as colors in fragment shader
	// to yield all possible ray volume exit positions to be stored in a texture for ray traversal.
	initVolumeBBoxCubeVBO();

	// load 1D transfer function texture from image
	loadTransferFunction1DTex("../transferfunctions/tff_grayscale.png");

	// init framebuffer to hold a 2D texture for volume exit positions of orthogonal rays
	// texture is autogenerated on framebuffer creation and will be filled with data later.
	initRayVolumeExitPosMapFramebuffer();

	viewOffset = QVector3D(0.f, 0.f, 1.8f);

}

void GLWidget::initShaders()
{
	raycastShader = new QOpenGLShaderProgram(QOpenGLContext::currentContext());
	raycastShader->addShaderFromSourceFile(QOpenGLShader::Vertex, "../src/shaders/raycast_shader.vert");
	raycastShader->addShaderFromSourceFile(QOpenGLShader::Fragment, "../src/shaders/raycast_shader.frag");
	raycastShader->link();

	rayVolumeExitPosMapShader = new QOpenGLShaderProgram(QOpenGLContext::currentContext());
	rayVolumeExitPosMapShader->addShaderFromSourceFile(QOpenGLShader::Vertex, "../src/shaders/rayvolumeexitposmap_shader.vert");
	rayVolumeExitPosMapShader->addShaderFromSourceFile(QOpenGLShader::Fragment, "../src/shaders/rayvolumeexitposmap_shader.frag");
	rayVolumeExitPosMapShader->link();

}

void GLWidget::initVolumeBBoxCubeVBO()
{
	// generate vertex array object (vao).
	// subsequent bindings related to vertex buffer data and shader variables
	// are stored by the bound vao, so they can conveniently be reused later.
	volumeBBoxCubeVAO.create();
	volumeBBoxCubeVAO.bind();

	// generate vertex buffer object (vbo) for raw vertex data
	QOpenGLBuffer volumeBBoxCubeVBO(QOpenGLBuffer::VertexBuffer);
	volumeBBoxCubeVBO.create();
	volumeBBoxCubeVBO.bind();
	volumeBBoxCubeVBO.setUsagePattern(QOpenGLBuffer::StaticDraw);
	volumeBBoxCubeVBO.allocate(&cubeVertices[0], 24 * sizeof(GLfloat));

	// generate index buffer object (ibo) listing vertex indices used for drawing
	QOpenGLBuffer volumeBBoxCubeIBO(QOpenGLBuffer::IndexBuffer);
	volumeBBoxCubeIBO.create();
	volumeBBoxCubeIBO.bind();
	volumeBBoxCubeIBO.setUsagePattern(QOpenGLBuffer::StaticDraw);
	volumeBBoxCubeIBO.allocate(&cubeTriangleIndices[0], 36 * sizeof(GLint));

	// bind vertex and index data to shader attributes
	rayVolumeExitPosMapShader->bind();
	int vertexPositionAttribIndex = rayVolumeExitPosMapShader->attributeLocation("vertexPosition");
	rayVolumeExitPosMapShader->enableAttributeArray(vertexPositionAttribIndex); // enable bound vertex buffer at this index
	rayVolumeExitPosMapShader->setAttributeBuffer(vertexPositionAttribIndex, GL_FLOAT, 0, 3); // 3 components x,y,z

	// unbind buffers and shader
	volumeBBoxCubeVAO.release();
	volumeBBoxCubeIBO.release();
	volumeBBoxCubeVBO.release();
	rayVolumeExitPosMapShader->release();

}

void GLWidget::loadTransferFunction1DTex(const QString &fileName)
{
	// load transfer function 1D texture from image file
	transferFunction1DTex = new QOpenGLTexture(QOpenGLTexture::Target1D);
	transferFunction1DTex->create();
	transferFunction1DTex->setFormat(QOpenGLTexture::RGB8_UNorm);
	transferFunction1DTex->setData(QImage(fileName).convertToFormat(QImage::Format_RGB888));
	transferFunction1DTex->setWrapMode(QOpenGLTexture::Repeat);
	transferFunction1DTex->setMinificationFilter(QOpenGLTexture::Nearest);
	transferFunction1DTex->setMagnificationFilter(QOpenGLTexture::Nearest);
}

void GLWidget::initRayVolumeExitPosMapFramebuffer()
{
	// init framebuffer to hold a 2D texture for volume exit positions of orthogonal rays
	// texture is autogenerated on framebuffer creation and will be filled with data later.

	QOpenGLFramebufferObjectFormat fboFormat;
	fboFormat.setAttachment(QOpenGLFramebufferObject::Depth);
	fboFormat.setTextureTarget(GL_TEXTURE_2D);
	fboFormat.setInternalTextureFormat(GL_RGBA8);

	rayVolumeExitPosMapFramebuffer = new QOpenGLFramebufferObject(this->width(), this->height(), fboFormat);

}

void GLWidget::loadVolume3DTex()
{
	if (!volume) { return; }

	// fill volumeData into a 3D texture
	if (volume3DTex) {
		volume3DTex->destroy(); delete volume3DTex; volume3DTex = nullptr;
	}
	volume3DTex = new QOpenGLTexture(QOpenGLTexture::Target3D);
	volume3DTex->create();
	volume3DTex->setFormat(QOpenGLTexture::R32F);
	volume3DTex->setWrapMode(QOpenGLTexture::Repeat);
	volume3DTex->setMinificationFilter(QOpenGLTexture::Linear); // this is trilinear interpolation
	volume3DTex->setMagnificationFilter(QOpenGLTexture::Linear);
	volume3DTex->bind();
	// we can simply pass a pointer to the voxel vector since vocels only have a float member each it is same as a float array
	// note that for some reason we need to use internalformat GL_RGB (i.e. 3 channels) since GL_INTENSITY doesnt work.
	// yet the pixel data is still interpreted as a single intensity value due to GL_INTENSITY.
	glf->glTexImage3D(GL_TEXTURE_3D, 0, GL_RGB, volume->getWidth(), volume->getHeight(), volume->getDepth(), 0, GL_LUMINANCE, GL_FLOAT, volume->getVoxels());

}

void GLWidget::precomputeGradients3DTex()
{
	if (!volume) { return; }

	gradients.clear();

	// gradients at each voxel are calculated using the sobel filter.
	// sobel filter kernels consist of an averaging and a difference kernel, i.e. compute the gradient with smoothing.
	// for each direction d, the smoothingKernel is applied to d+1 and d-1 to average the values along the other directions,
	// then difference of the two values is taken. here we do this for all 3 directions to build the gradient vector.

	float smoothingKernel[9] = {  1, 2, 1, 2, 4, 2, 1, 2, 1 };
	float offsets1[9]        = { -1,-1,-1, 0, 0, 0, 1, 1, 1 };
	float offsets2[9]        = { -1, 0, 1,-1, 0, 1,-1, 0, 1 };

	for (int x = 0; x < volume->getWidth(); ++x) {
		for (int y = 0; y < volume->getHeight(); ++y) {
			for (int z = 0; z < volume->getDepth(); ++z) {

				float gradientX, gradientY, gradientZ;

				for (int i = 0; i < 9; ++i) {
					gradientX += volume->valueAt(x-1, y+offsets1[i], z+offsets2[i]) * smoothingKernel[i];
					gradientX -= volume->valueAt(x+1, y+offsets1[i], z+offsets2[i]) * smoothingKernel[i];

					gradientY += volume->valueAt(x+offsets1[i], y-1, z+offsets2[i]) * smoothingKernel[i];
					gradientY -= volume->valueAt(x+offsets1[i], y+1, z+offsets2[i]) * smoothingKernel[i];

					gradientZ += volume->valueAt(x+offsets1[i], y+offsets2[i], z-1) * smoothingKernel[i];
					gradientZ -= volume->valueAt(x+offsets1[i], y+offsets2[i], z+1) * smoothingKernel[i];
				}

				gradients.push_back(QVector3D(gradientX, gradientY, gradientZ));

			}
		}
	}

	// fill gradients into a 3D texture
	if (gradients3DTex) {
		gradients3DTex->destroy(); delete gradients3DTex; gradients3DTex = nullptr;
	}
	gradients3DTex = new QOpenGLTexture(QOpenGLTexture::Target3D);
	gradients3DTex->create();
	gradients3DTex->setWrapMode(QOpenGLTexture::Repeat);
	gradients3DTex->setMinificationFilter(QOpenGLTexture::Linear); // trilinear interpolation
	gradients3DTex->setMagnificationFilter(QOpenGLTexture::Linear);
	gradients3DTex->bind();

	// TODO TEXTURE FORMAT IS BROKEN
	glf->glTexImage3D(GL_TEXTURE_3D, 0, GL_RGB32F, volume->getWidth(), volume->getHeight(), volume->getDepth(), 0, GL_RGB32F, GL_FLOAT, &gradients[0]);

}

void GLWidget::dataLoaded(Volume *volumeData)
{
	volume = volumeData;

	loadVolume3DTex();
    repaint();
	//precomputeGradients3DTex();

}

void GLWidget::paintGL()
{
	glf->glClearColor(backgroundColor.red()/256.0f, backgroundColor.green()/256.0f, backgroundColor.blue()/256.0f, 1.0f);
	glf->glClear(GL_COLOR_BUFFER_BIT);

	if (!volume) { return; }

	glf->glEnable(GL_DEPTH_TEST);

	///////////////////////////////////////////////////////////////////////////////
	// FIRST PASS
	// generate ray volume exit position map later used to construct rays
	///////////////////////////////////////////////////////////////////////////////

	rayVolumeExitPosMapFramebuffer->bind();

	rayVolumeExitPosMapShader->bind();

	// draw volume cube back faces (front face culling enabled)
	// rayVolumeExitPosMapShader stores interpolated back face (ray exit) positions in framebuffer texture
	drawVolumeBBoxCube(GL_FRONT, rayVolumeExitPosMapShader);

	///////////////////////////////////////////////////////////////////////////////
	// SECOND PASS
	// calculate ray volume entry positions and together with exit position map
	// do raycasting from entry to exit position of each fragment
	///////////////////////////////////////////////////////////////////////////////

	QOpenGLFramebufferObject::bindDefault();

	raycastShader->bind();
	raycastShader->setUniformValue("screenDimensions", QVector2D(this->width(), this->height()));
	raycastShader->setUniformValue("numSamples", numSamples);
	raycastShader->setUniformValue("sampleRangeStart", sampleRangeStart);
	raycastShader->setUniformValue("sampleRangeEnd", sampleRangeEnd);
	raycastShader->setUniformValue("compositingMethod", compositingMethod);
	raycastShader->setUniformValue("enableShading", enableShading);
    raycastShader->setUniformValue("shadingThreshold", shadingThreshold);

	raycastShader->setUniformValue("transferFunction", 0); // bind shader uniform to texture unit 0
    transferFunction1DTex->bind(0); // bind texture to texture unit 0
	raycastShader->setUniformValue("exitPositions", 1);
	glActiveTexture(GL_TEXTURE0 + 1);
	glBindTexture(GL_TEXTURE_2D, rayVolumeExitPosMapFramebuffer->texture());
	raycastShader->setUniformValue("volume", 2);
	volume3DTex->bind(2);
	//raycastShader->setUniformValue("gradients", 3);
	//gradients3DTex->bind(3);

	// draw volume cube front faces (back face culling enabled)
	// raycastShader then uses interpolated front face (ray entry) positions with exit positions from first pass
	// to cast rays through the volume texture.
	// raycasting determines pixel intensity by sampling the volume voxel intensities
	// and mapping desired values to colors via the transfer function
	drawVolumeBBoxCube(GL_BACK, raycastShader);

	/*/ DEBUG VIEW FIRST PASS TEXTURE
	// blit framebuffer from first pass to default framebuffer
	// blit = bit block image transfer, combine bitmaps via boolean operation
	if (!QOpenGLFramebufferObject::hasOpenGLFramebufferBlit()) qWarning() << "Frame Buffer blitting not supported by local OpenGL implementation.";
	QOpenGLFramebufferObject::blitFramebuffer(0, rayVolumeExitPosMapFramebuffer); //*/

}

void GLWidget::drawVolumeBBoxCube(GLenum glFaceCullMode, QOpenGLShaderProgram *shader)
{
	glf->glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	// note that it doesnt matter to volume sampling how we transform the cube, since sampling rays are created between interpolated model space vertex positions
	modelMat.setToIdentity();
	modelMat.rotate(90 - volumeRotAngleX, QVector3D(1, 0, 0));
	QMatrix4x4 rotMatY;
	rotMatY.rotate(volumeRotAngleY, QVector3D(0, 1, 0));
	modelMat = rotMatY * modelMat;
	modelMat.translate(QVector3D(-0.5, -0.5, -0.5)); // move volume bounding box cube to center
	viewMat.setToIdentity();
    viewMat.lookAt(QVector3D(0.0f, 0.0f, viewOffset.z()), QVector3D(0.0f, 0.0f, 0.0f), QVector3D(0.0f, 1.0f, 0.0f)); // move camera slightly back and look at center
	viewMat.translate(viewOffset.x(), viewOffset.y(), 0.0f);
	projMat.setToIdentity();
	projMat.perspective(60, this->width()/this->height(), 0.01f, 1000.f);
	//projMat.ortho(-0.8f, 0.8f, -0.8f, 0.8f, 0.8f, 1000.f);

	shader->bind();
	int mvpMatUniformIndex = shader->uniformLocation("modelViewProjMat");
	shader->setUniformValue(mvpMatUniformIndex, projMat * viewMat * modelMat);

	glf->glEnable(GL_CULL_FACE);
	glf->glCullFace(glFaceCullMode);
	volumeBBoxCubeVAO.bind();
	glf->glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, (GLuint *)NULL);
	glf->glDisable(GL_CULL_FACE);

}

void GLWidget::resizeGL(int w, int h)
{
	// TODO

	rayVolumeExitPosMapFramebuffer = new QOpenGLFramebufferObject(w, h, QOpenGLFramebufferObject::Depth);

}

void GLWidget::setNumSamples(int numSamples)
{
	this->numSamples = numSamples;
	repaint();
}

void GLWidget::setSampleRangeStart(double sampleRangeStart)
{
	this->sampleRangeStart = float(sampleRangeStart);
	repaint();
}

void GLWidget::setSampleRangeEnd(double sampleRangeEnd)
{
	this->sampleRangeEnd = float(sampleRangeEnd);
	repaint();
}

void GLWidget::setShadingThreshold(double thresh)
{
    this->shadingThreshold = thresh;
    repaint();
}

void GLWidget::setCompositingMethod(CompositingMethod m)
{
	this->compositingMethod = m;
    repaint();
}

void GLWidget::loadTransferFunctionImage()
{
	QString fileName = QFileDialog::getOpenFileName(this, tr("Open Image"), "/home", tr("Image Files (*.png *.jpg)"));
	loadTransferFunction1DTex(fileName);

	repaint();
}

void GLWidget::setShading(bool shade)
{
	this->enableShading = shade;
    repaint();
}

void GLWidget::mousePressEvent(QMouseEvent *event)
{
	this->numSamplesInteractive = this->numSamples > 5 ? this->numSamples : this->numSamplesInteractive;
	lastMousePos = event->pos();
}

void GLWidget::mouseMoveEvent(QMouseEvent *event)
{
    this->numSamples = 5; // SET SAMPLES LOWER FOR BETTER PERFORMANCE; RESET AFTER MOUSE RELEASE
	int dx = event->x() - lastMousePos.x();
	int dy = event->y() - lastMousePos.y();

	if (event->buttons() & Qt::LeftButton) {
		if (event->modifiers() & Qt::AltModifier) { // ZOOM
			viewOffset += QVector3D(0, 0, -dy/40.f);
			if (viewOffset.z() >  3.f) viewOffset.setZ(3.f);
			if (viewOffset.z() <  0.8f) viewOffset.setZ(0.8f);
		} else if (event->modifiers() & Qt::ControlModifier) { // PAN
			viewOffset += QVector3D(dx, -dy, 0.0f)/60.f;
			if (viewOffset.x() >  1) viewOffset.setX( 1);
			if (viewOffset.x() < -1) viewOffset.setX(-1);
			if (viewOffset.y() >  1) viewOffset.setY( 1);
			if (viewOffset.y() < -1) viewOffset.setY(-1);
		} else { // ROTATE
			if ((dy > 0 && volumeRotAngleX < 90) || (dy < 0 && volumeRotAngleX > -90)) {
				volumeRotAngleX += dy;
			}
			volumeRotAngleY += dx;
			if (volumeRotAngleX < -90) volumeRotAngleX = -90;
			if (volumeRotAngleX >  90) volumeRotAngleX =  90;
		}
	}
	lastMousePos = event->pos();

	repaint();
}

void GLWidget::mouseReleaseEvent(QMouseEvent *)
{
	this->numSamples = this->numSamplesInteractive;
    repaint();
}

GLWidget::~GLWidget()
{
	delete logger; logger = nullptr;
	delete glf; glf = nullptr;

	delete raycastShader; raycastShader = nullptr;
	delete rayVolumeExitPosMapShader; rayVolumeExitPosMapShader = nullptr;

	delete transferFunction1DTex; transferFunction1DTex = nullptr;
	delete rayVolumeExitPosMapFramebuffer; rayVolumeExitPosMapFramebuffer = nullptr;
	delete volume3DTex; volume3DTex = nullptr;
	delete gradients3DTex; gradients3DTex = nullptr;
}
